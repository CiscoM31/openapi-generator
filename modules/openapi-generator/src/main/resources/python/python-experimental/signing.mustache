# coding: utf-8
{{>partial_header}}
from __future__ import absolute_import

from six.moves.urllib.parse import urlencode, urlparse
import pem
from Crypto.PublicKey import RSA, ECC
from Crypto.Signature import PKCS1_v1_5, pss, DSS
from Crypto.Hash import SHA256, SHA512
from base64 import b64encode
from email.utils import formatdate

HEADER_REQUEST_TARGET = '(request-target)'
HEADER_CREATED = '(created)'
HEADER_EXPIRES = '(expires)'
HEADER_HOST = 'host'
HEADER_DATE = 'date'
HEADER_DIGEST = 'Digest'

SCHEME_HS2019 = 'hs2019'

ALGORITHM_RSASSA_PSS = 'PSS'
ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'

ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'
ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'
ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}

def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):
    """
    Create a cryptographic message signature for the HTTP request and add the signed headers.
    
    :param resource_path : A string representation of the HTTP request resource path.
    :param method: A string representation of the HTTP request method, e.g. GET, POST.
    :param headers: A dict containing the HTTP request headers.
    :param body: The string representation of the HTTP request body.
    :param query_params: A string representing the HTTP request query parameters.
    :return: A dict of HTTP headers that must be added to the outbound HTTP request.
    """
    if method is None:
        raise Exception("HTTP method must be set")
    if resource_path is None:
        raise Exception("Resource path must be set")

    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,
        resource_path, method, headers, body, query_params)

    header_items = ["{0}: {1}".format(key.lower(), value) for key, value in signed_headers_dict.items()]
    string_to_sign = "\n".join(header_items)

    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())
    b64_signed_msg = sign_digest(configuration, digest)

    request_headers_dict['Authorization'] = get_authorization_header(configuration,
        signed_headers_dict, b64_signed_msg)

    return request_headers_dict

def load_private_key(configuration):
    """Load the private key used to sign HTTP requests.
        The private key is used to sign HTTP requests as defined in
        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.
    """
    if configuration.private_key is not None:
        return
    with open(configuration.private_key_path, "rb") as f:
        # Decode PEM file and determine key type from PEM header.
        # Supported values are "RSA PRIVATE KEY" and "ECDSA PRIVATE KEY".
        keys = pem.parse(f.read())
        if len(keys) != 1:
            raise Exception("File must contain exactly one private key")
        key = keys[0].as_text()
        if key.startswith("-----BEGIN RSA PRIVATE KEY-----"):
            configuration.private_key = RSA.importKey(key)
        elif key.startswith("-----BEGIN EC PRIVATE KEY-----"):
            configuration.private_key = ECC.importKey(key)
        else:
            raise Exception("Unsupported key")

def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):
    """
    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.

    :param resource_path : A string representation of the HTTP request resource path.
    :param method: A string representation of the HTTP request method, e.g. GET, POST.
    :param headers: A dict containing the HTTP request headers.
    :param body: The string representation of the HTTP request body.
    :param query_params: A string representing the HTTP request query parameters.
    :return: A tuple containing two dict objects:
        The first dict contains the HTTP headers that are used to calculate the HTTP signature.
        The second dict contains the HTTP headers that must be added to the outbound HTTP request.
    """

    if body is None:
        body = ''
    else:
        body = json.dumps(body)

    # Build the '(request-target)' HTTP signature parameter.
    target_host = urlparse(configuration.host).netloc
    target_path = urlparse(configuration.host).path
    request_target = method.lower() + " " + target_path + resource_path
    if query_params:
        raw_query = urlencode(query_params).replace('+', '%20')
        request_target += "?" + raw_query

    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.
    now = datetime.datetime.now()
    stamp = mktime(now.timetuple())
    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)
    created = now.strftime("%s")
    if configuration.signature_max_validity is not None:
        expires = (now + configuration.signature_max_validity).strftime("%s")

    signed_headers_dict = {}
    request_headers_dict = {}
    for hdr_key in configuration.signed_headers_dict:
        hdr_key = hdr_key.lower()
        if hdr_key == HEADER_REQUEST_TARGET:
            value = request_target
        elif hdr_key == HEADER_CREATED:
            value = created
        elif hdr_key == HEADER_EXPIRES:
            value = expires
        elif hdr_key == HEADER_DATE:
            value = cdate
            request_headers_dict['Date'] = '{0}'.format(cdate)
        elif hdr_key == HEADER_DIGEST:
            request_body = body.encode()
            body_digest, digest_prefix = get_message_digest(configuration, request_body)
            b64_body_digest = b64encode(body_digest.digest())
            value = digest_prefix + b64_body_digest.decode('ascii')
            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))
        elif hdr_key == HEADER_HOST:
            value = target_host
            request_headers_dict['Host'] = '{0}'.format(target_host)
        else:
            value = headers[hdr_key]
        signed_headers_dict[hdr_key] = value

    # If the user has not provided any signed_headers, the default must be set to '(created)'.
    if len(configuration.signed_headers_dict) == 0:
        signed_headers_dict[HEADER_CREATED] = created

    return signed_header_dict, request_headers_dict

def get_message_digest(configuration, data):
    """
    Calculates and returns a cryptographic digest of a specified HTTP request.

    :param data: The string representation of the date to be hashed with a cryptographic hash.
    :return: A tuple of (digest, prefix).
        The digest is a hashing object that contains the cryptographic digest of the HTTP request.
        The prefix is a string that identifies the cryptographc hash. It is used to generate the
        'Digest' header as specified in RFC 3230.
    """
    if configuration.signing_scheme in ["rsa-sha512", "hs2019"]:
        digest = SHA512.new()
        prefix = "SHA-512="
    elif configuration.signing_scheme in ["rsa-sha256"]:
        digest = SHA256.new()
        prefix = "SHA-256="
    else:
        raise Exception(
            "Unsupported signing algorithm: {0}".format(configuration.signing_scheme))
    digest.update(data)
    return digest, prefix

def sign_digest(configuration, digest):
    """
    Signs a message digest with a private key specified in the configuration.

    :param digest: A hashing object that contains the cryptographic digest of the HTTP request.
    :return: A base-64 string representing the cryptographic signature of the input digest.
    """
    load_private_key(configuration)
    privkey = self.private_key
    if isinstance(privkey, RSA.RsaKey):
        if configuration.signing_algorithm == ALGORITHM_RSASSA_PSS:
            # RSASSA-PSS in Section 8.1 of RFC8017.
            signature = pss.new(privkey).sign(digest)
        elif configuration.signing_algorithm == ALGORITHM_RSASSA_PKCS1v15:
            # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.
            signature = PKCS1_v1_5.new(privkey).sign(digest)
        else:
            raise Exception("Unsupported signature algorithm: {0}".format(configuration.signing_algorithm))
    elif isinstance(privkey, ECC.EccKey):
        if configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:
            signature = DSS.new(privkey, configuration.signing_algorithm).sign(digest)
        else:
            raise Exception("Unsupported signature algorithm: {0}".format(configuration.signing_algorithm))
    else:
        raise Exception("Unsupported private key: {0}".format(type(privkey)))
    return b64encode(signature)

def get_authorization_header(configuration, signed_headers, signed_msg):
    """
    Calculates and returns the value of the 'Authorization' header when signing HTTP requests.
    
    :param signed_headers : A list of strings. Each value is the name of a HTTP header that
        must be included in the HTTP signature calculation.
    :param signed_msg: A base-64 encoded string representation of the signature.
    :return: The string value of the 'Authorization' header, representing the signature
        of the HTTP request.
    """

    headers_value = ""
    created_ts = signed_headers.get(HEADER_CREATED)
    expires_ts = signed_headers.get(HEADER_EXPIRES)
    lower_keys = [k.lower() for k in signed_headers]
    headers_value = " ".join(lower_keys)

    auth_str = "Signature keyId=\"{0}\",algorithm=\"{1}\","
        .format(configuration.key_id, configuration.signing_scheme)
    if created_ts is not None:
        auth_str = auth_str + "created={0},".format(created_ts)
    if expires_ts is not None:
        auth_str = auth_str + "expires={0},".format(expires_ts)
    auth_str = auth_str + "headers=\"{0}\",signature=\"{1}\""
        .format(headers_value, signed_msg.decode('ascii'))
    return auth_str
