{{#hasHttpSignatureMethods}}
# coding: utf-8
{{>partial_header}}
from __future__ import absolute_import

from six.moves.urllib.parse import urlencode, urlparse
from Crypto.PublicKey import RSA, ECC
from Crypto.Signature import PKCS1_v1_5, pss, DSS
from Crypto.Hash import SHA256, SHA512
from base64 import b64encode
from email.utils import formatdate

class HttpSignatureHandler(object):
    """OpenAPI HTTP signature handler to generate and verify HTTP signatures.

    NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech
    Do not edit the class manually.

    :param configuration: .Configuration object for this client
    """

    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'
    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'
    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}

    def __init__(self, configuration=None):
        if configuration is None:
            raise Exception("Configuration must be specified")
        self.configuration = configuration

    def get_signed_header_info(self, resource_path, method, headers, body, query_params):
        """
        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.

        :param resource_path : A string representation of the HTTP request resource path.
        :param method: A string representation of the HTTP request method, e.g. GET, POST.
        :param headers: A dict containing the HTTP request headers.
        :param body: The string representation of the HTTP request body.
        :param query_params: A string representing the HTTP request query parameters.
        :return: A tuple containing two dict objects:
            The first dict contains the HTTP headers that are used to calculate the HTTP signature.
            The second dict contains the HTTP headers that must be added to the outbound HTTP request.
        """

        if body is None:
            body = ''
        else:
            body = json.dumps(body)

        # Build the '(request-target)' HTTP signature parameter.
        target_host = urlparse(self.configuration.host).netloc
        target_path = urlparse(self.configuration.host).path
        request_target = method.lower() + " " + target_path + resource_path
        if query_params:
            raw_query = urlencode(query_params).replace('+', '%20')
            request_target += "?" + raw_query

        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.
        now = datetime.datetime.now()
        stamp = mktime(now.timetuple())
        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)
        created = now.strftime("%s")
        if self.configuration.signature_max_validity is not None:
            expires = (now + self.configuration.signature_max_validity).strftime("%s")

        signed_headers_dict = {}
        request_headers_dict = {}
        for hdr_key in self.configuration.signed_headers_dict:
            hdr_key = hdr_key.lower()
            if hdr_key == '(request-target)':
                value = request_target
            elif hdr_key == '(created)':
                value = created
            elif hdr_key == '(expires)':
                value = expires
            elif hdr_key == 'date':
                value = cdate
                request_headers_dict['Date'] = '{0}'.format(cdate)
            elif hdr_key == 'digest':
                request_body = body.encode()
                body_digest, digest_prefix = self.get_message_digest(request_body)
                b64_body_digest = b64encode(body_digest.digest())
                value = digest_prefix + b64_body_digest.decode('ascii')
                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))
            elif hdr_key == 'host':
                value = target_host
                request_headers_dict['Host'] = '{0}'.format(target_host)
            else:
                value = headers[hdr_key]
            signed_headers_dict[hdr_key] = value

        # If the user has not provided any signed_headers, the default must be set to '(created)'.
        if len(self.configuration.signed_headers_dict) == 0:
            signed_headers_dict['(created)'] = created

        return signed_header_dict, request_headers_dict

    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):
        """
        Create a cryptographic message signature for the HTTP request and add the signed headers.
        
        :param resource_path : A string representation of the HTTP request resource path.
        :param method: A string representation of the HTTP request method, e.g. GET, POST.
        :param headers: A dict containing the HTTP request headers.
        :param body: The string representation of the HTTP request body.
        :param query_params: A string representing the HTTP request query parameters.
        :return: A dict of HTTP headers that must be added to the outbound HTTP request.
        """
        if method is None:
            raise Exception("HTTP method must be set")
        if resource_path is None:
            raise Exception("Resource path must be set")

        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,
            resource_path, method, headers, body, query_params)

        header_items = ["{0}: {1}".format(key.lower(), value) for key, value in signed_headers_dict.items()]
        string_to_sign = "\n".join(header_items)

        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())
        b64_signed_msg = self.sign_digest(digest)

        request_headers_dict['Authorization'] = self.get_authorization_header(
            signed_headers_dict, b64_signed_msg)

        return request_headers_dict

    def get_message_digest(self, data):
        """
        Calculates and returns a cryptographic digest of a specified HTTP request.

        :param data: The string representation of the date to be hashed with a cryptographic hash.
        :return: A tuple of (digest, prefix).
          The digest is a hashing object that contains the cryptographic digest of the HTTP request.
          The prefix is a string that identifies the cryptographc hash. It is used to generate the
          'Digest' header as specified in RFC 3230.
        """
        if self.configuration.signing_scheme in ["rsa-sha512", "hs2019"]:
            digest = SHA512.new()
            prefix = "SHA-512="
        elif self.configuration.signing_scheme in ["rsa-sha256"]:
            digest = SHA256.new()
            prefix = "SHA-256="
        else:
            raise Exception(
                "Unsupported signing algorithm: {0}".format(self.configuration.signing_scheme))
        digest.update(data)
        return digest, prefix

    def sign_digest(self, digest):
        """
        Signs a message digest with a private key specified in the configuration.

        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.
        :return: A base-64 string representing the cryptographic signature of the input digest.
        """
        self.configuration.load_private_key()
        privkey = self.configuration.private_key
        if isinstance(privkey, RSA.RsaKey):
            if self.configuration.signing_algorithm == 'PSS':
                # RSASSA-PSS in Section 8.1 of RFC8017.
                signature = pss.new(privkey).sign(digest)
            elif self.configuration.signing_algorithm == 'PKCS1v15':
                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.
                signature = PKCS1_v1_5.new(privkey).sign(digest)
            else:
                raise Exception("Unsupported signature algorithm: {0}".format(self.configuration.signing_algorithm))
        elif isinstance(privkey, ECC.EccKey):
            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:
                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)
            else:
                raise Exception("Unsupported signature algorithm: {0}".format(self.configuration.signing_algorithm))
        else:
            raise Exception("Unsupported private key: {0}".format(type(privkey)))
        return b64encode(signature)

    def get_authorization_header(self, signed_headers, signed_msg):
        """
        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.
        
        :param signed_headers : A list of strings. Each value is the name of a HTTP header that
           must be included in the HTTP signature calculation.
        :param signed_msg: A base-64 encoded string representation of the signature.
        :return: The string value of the 'Authorization' header, representing the signature
           of the HTTP request.
        """

        headers_value = ""
        created_ts = signed_headers.get('(created)')
        expires_ts = signed_headers.get('(expires)')
        lower_keys = [k.lower() for k in signed_headers]
        headers_value = " ".join(lower_keys)

        auth_str = "Signature keyId=\"{0}\",algorithm=\"{1}\","
            .format(self.configuration.key_id, self.configuration.signing_scheme)
        if created_ts is not None:
            auth_str = auth_str + "created={0},".format(created_ts)
        if expires_ts is not None:
            auth_str = auth_str + "expires={0},".format(expires_ts)
        auth_str = auth_str + "headers=\"{0}\",signature=\"{1}\""
            .format(headers_value, signed_msg.decode('ascii'))
        return auth_str
{{/hasHttpSignatureMethods}}
