# coding: utf-8

{{>partial_header}}

from __future__ import absolute_import

import logging
{{^asyncio}}
import multiprocessing
{{/asyncio}}
{{#hasHttpSignatureMethods}}
import pem
from Crypto.PublicKey import RSA, ECC
{{/hasHttpSignatureMethods}}
import sys
import urllib3

import six
from six.moves import http_client as httplib


class Configuration(object):
    """NOTE: This class is auto generated by OpenAPI Generator

    Ref: https://openapi-generator.tech
    Do not edit the class manually.

    :param host: Base url
    :param api_key: Dict to store API key(s)
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)
    :param username: Username for HTTP basic authentication
    :param password: Password for HTTP basic authentication
    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.
        An 'Authorization' header is calculated by creating a hash of select headers,
        and optionally the body of the HTTP request, then signing the hash value using
        a private key which is available to the client.
    :param private_key_path: The path of the file containing a private key,
        when signing HTTP requests.
    :param signing_scheme: The signature scheme, when signing HTTP requests.
        Supported value is hs2019.
    :param signing_algorithm: The signature algorithm, when signing HTTP requests.
        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.
    :param signed_headers: A list of HTTP headers that must be added to the signed message,
        when signing HTTP requests.
        The two special signature headers '(request-target)' and '(created)' SHOULD be
        included in SignedHeaders.
        The '(created)' header expresses when the signature was created.
        The '(request-target)' header is a concatenation of the lowercased :method, an
        ASCII space, and the :path pseudo-headers.
        When signed_headers is not specified, the client defaults to a single value,
        '(created)', in the list of HTTP headers.
        When SignedHeaders contains the 'Digest' value, the client performs the
        following operations:
        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.
        2. Set the 'Digest' header in the request body.
        3. Include the 'Digest' header and value in the HTTP signature.

    :Example:

    Configure HTTP signature:
      conf = {{{packageName}}}.Configuration(
        key_id='my-key-id',
        private_key_path='rsa.pem',
        signing_scheme='hs2019',
        signing_algorithm='PSS',
        signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']
      )
    """

    def __init__(self, host="{{{basePath}}}",
                 api_key=None, api_key_prefix=None,
                 username="", password="",
                 key_id=None, private_key_path=None, signing_scheme=None,
                 signing_algorithm=None, signed_headers=None):
        """Constructor
        """
        self.host = host
        """Default Base url
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.key_id = key_id
        """The identifier of the key used to sign HTTP requests.
        """
        self.private_key_path = private_key_path
        """The path of the file containing a private key, used to sign HTTP requests.
        """
        self.signing_scheme = signing_scheme
        """The signature scheme when signing HTTP requests.
           Supported values are hs2019, rsa-sha256, rsa-sha512.
        """
        self.signing_algorithm = signing_algorithm
        """The signature algorithm when signing HTTP requests.
           For RSA keys, supported values are PKCS1v15, PSS.
           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.
        """
        self.signed_headers = signed_headers
        """A list of HTTP headers that must be signed, when signing HTTP requests.
        """
{{#hasOAuthMethods}}
        self.access_token = ""
        """access token for OAuth/Bearer
        """
{{/hasOAuthMethods}}
{{^hasOAuthMethods}}
{{#hasBearerMethods}}
        self.access_token = ""
        """access token for OAuth/Bearer
        """
{{/hasBearerMethods}}
{{/hasOAuthMethods}}
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("{{packageName}}")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        self.debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = None
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
{{#hasHttpSignatureMethods}}
        self.private_key = None
        """The private key used to sign HTTP requests.
           Initialized when the PEM-encoded private key is loaded from a file.
        """
{{/hasHttpSignatureMethods}}

        {{#asyncio}}
        self.connection_pool_maxsize = 100
        """This value is passed to the aiohttp to limit simultaneous connections.
           Default values is 100, None means no-limit.
        """
        {{/asyncio}}
        {{^asyncio}}
        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
        """urllib3 connection pool's maximum number of connections saved
           per pool. urllib3 uses 1 connection as default value, but this is
           not the best value when you are making a lot of possibly parallel
           requests to the same host, which is often the case here.
           cpu_count * 5 is used as default value to increase performance.
        """
        {{/asyncio}}

        self.proxy = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = None
        """Adding retries to override urllib3 default value 3
        """
        # Disable client side validation
        self.client_side_validation = True

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in six.iteritems(self.logger):
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in six.iteritems(self.logger):
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default `logging.WARNING`
            for _, logger in six.iteritems(self.logger):
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        return urllib3.util.make_headers(
            basic_auth=self.username + ':' + self.password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        return {
{{#authMethods}}
{{#isApiKey}}
            '{{name}}':
                {
                    'type': 'api_key',
                    'in': {{#isKeyInCookie}}'cookie'{{/isKeyInCookie}}{{#isKeyInHeader}}'header'{{/isKeyInHeader}}{{#isKeyInQuery}}'query'{{/isKeyInQuery}},
                    'key': '{{keyParamName}}',
                    'value': self.get_api_key_with_prefix('{{keyParamName}}')
                },
{{/isApiKey}}
{{#isBasic}}
  {{#isBasicBasic}}
            '{{name}}':
                {
                    'type': 'basic',
                    'in': 'header',
                    'key': 'Authorization',
                    'value': self.get_basic_auth_token()
                },
  {{/isBasicBasic}}
  {{#isBasicBearer}}
            '{{name}}':
                {
                    'type': 'bearer',
                    'in': 'header',
                    {{#bearerFormat}}
                    'format': '{{{.}}}',
                    {{/bearerFormat}}
                    'key': 'Authorization',
                    'value': 'Bearer ' + self.access_token
                },
  {{/isBasicBearer}}
  {{#isHttpSignature}}
            '{{name}}':
                {
                    'type': 'http-signature',
                    'in': 'header',
                    'key': 'Authorization',
                    'value': None  # Signature headers are calculated for every HTTP request
                },
  {{/isHttpSignature}}
{{/isBasic}}
{{#isOAuth}}
            '{{name}}':
                {
                    'type': 'oauth2',
                    'in': 'header',
                    'key': 'Authorization',
                    'value': 'Bearer ' + self.access_token
                },
{{/isOAuth}}
{{/authMethods}}
        }
{{#hasHttpSignatureMethods}}

    def load_private_key(self):
        """Load the private key used to sign HTTP requests.
           The private key is used to sign HTTP requests as defined in
           https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.
        """
        if self.private_key is not None:
            return
        with open(self.private_key_path, "rb") as f:
            # Decode PEM file and determine key type from PEM header.
            # Supported values are "RSA PRIVATE KEY" and "ECDSA PRIVATE KEY".
            keys = pem.parse(f.read())
            if len(keys) != 1:
                raise Exception("File must contain exactly one private key")
            key = keys[0].as_text()
            if key.startswith("-----BEGIN RSA PRIVATE KEY-----"):
                self.private_key = RSA.importKey(key)
            elif key.startswith("-----BEGIN EC PRIVATE KEY-----"):
                self.private_key = ECC.importKey(key)
            else:
                raise Exception("Unsupported key")
{{/hasHttpSignatureMethods}}

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\n"\
               "OS: {env}\n"\
               "Python Version: {pyversion}\n"\
               "Version of the API: {{version}}\n"\
               "SDK Package Version: {{packageVersion}}".\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {{#servers}}
            {
                'url': "{{{url}}}",
                'description': "{{{description}}}{{^description}}No description provided{{/description}}",
                {{#variables}}
                {{#-first}}
                'variables': {
                {{/-first}}
                    '{{{name}}}': {
                        'description': "{{{description}}}{{^description}}No description provided{{/description}}",
                        'default_value': "{{{defaultValue}}}",
                        {{#enumValues}}
                        {{#-first}}
                        'enum_values': [
                        {{/-first}}
                            "{{{.}}}"{{^-last}},{{/-last}}
                        {{#-last}}
                        ]
                        {{/-last}}
                        {{/enumValues}}
                        }{{^-last}},{{/-last}}
                {{#-last}}
                    }
                {{/-last}}
                {{/variables}}
            }{{^-last}},{{/-last}}
            {{/servers}}
        ]

    def get_host_from_settings(self, index, variables=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :return: URL based on host settings
        """
        variables = {} if variables is None else variables
        servers = self.get_host_settings()

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server['variables'].items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable `{0}` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url
